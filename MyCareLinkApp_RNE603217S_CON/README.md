# Azure-Pacemaker-Attack

Sniffering tool: Adafruit Bluefruit LE Friend (unstable, not always be able to capture/ capture all packets :-()

Analysis tool: Wireshark

Analysis target: Azure pacemaker RNE603217S, Medtronic MyCareLink Heart App

**All the .pcapng files could only be viewed using Wireshark**

**The 'master' means the mobile phone App, the 'slave' means the pacemaker**

## Files Description:

- The file **'Azure RNE603217S Attribute Table'** contains the attribute table of the pacemaker.

- The capturing files (starting with **'MyCareLinkApp_RNE603217S_Sniff'**) contain the packets when using the Medtronic MyCareLink App to connect with the pacemaker. The connection could be triggered using the 'Send Transmission' function of the App, and each .pcapng file contains the aggregate sniffered packets throughout one 'Send Transmission' process.  All the files show that the connection between the Medtronic App and pacemaker is complete, for example, it starts from master transmitting 'CONNECT_REQ' and ends with master transmitting 'LL_TERMINATE_IND'. By analysing the packets, the attribute table of the pacemaker could be generated (See file **'Azure RNE603217S Attribute Table'**). One interesting thing is that for the communications between pacemaker and MyCareLink App, I could capture two communications in two different advertising intervals (advertising interval is 3 mins for pacemaker), and they have similar structures. The reason why the second communication exists is still unknown.

#### Note: 
  Although lots of attempts, because of the limitation of the sniffering tool, not all the communication info has been captured completely in each file. Ex, for the recording file **'Azure pacemaker Packets1'**, the second communication between pacemaker and Medtronic App is not complete.


## Whole Communication Process:

### The first communication:
  1. After the connection is established, the master uses 'Read by group type REQ/RSP', 'Read by type REQ/RSP', 'Find Information REQ/RSP' to learn the info of services, characteristics and descriptors of the slave respectively. 
  2. At the same time, the master writes data into descriptor attributes 0x000F, 0x0016, 0x0019 to trigger the Indication/Notification functions of the slave's characteristics. 
  3. Next, the master writes 30 bytes data into the attribute 0x0012. The 30 bytes are different each time, however, not completely random. For instance, three examples 
*0x19380200000008000006de526175e4ef9dffcc65982046a80fc573e1a253*, *0x1938010000000700000636903df073fb7a886dfcfd17439bf34508cf7*, *0x1938010000000d0000067766194dfa1ad18cd8643859c0729c0b12371435*. 
  It's still unknown what these data represents.
  4. The slave sends a 6-byte Indication to the master, from attribute 0x0018. These 6 bytes are constant: 0x0000ace10100. There'll be a Confirmation packet sent back to the slave from the master.
  5. The slave keeps sending Notifications to the master from attribute 0x0015 (Over 5000 Notifications totally). Most of the Notifications contain 20 bytes value, however, it's found that a few contain 18 bytes/8 bytes/2 bytes as well (occur at last). The number of Notifications varies in each test. (I think it might be the sniffer problem, but haven't proved)
  6. During the period of slave sending Notifications, the master keeps sending the Write Commands on attribute 0x001B regularly (Write again after about 10-20 Notifications). The value of each Write contains 9 bytes. The interesting thing is that, only the Least Significant byte (LSB) is not 0x00. The LSB values of the first Write Commands are always '0x14', '0x28', '0x3C', etc, and the value of the last Write Command is always '0xF9'. However, for the values in the middle Write Commands, they are not always the same in each test. (I think it might be the sniffer problem, but haven't proved)
  7. After all Notifications are sent, the salve will send a 2-byte Indication from attribute 0x0018. The content is constant: 0x0200. There's no Confirmation packet from the master.
  8. After receiving the Indication, the master sends back an 'LL_TERMINATE_IND' packet. The whole connection is over.
  
### The second communication:
  The second communication between the Medtronic App and the pacemaker happens in a different slave's advertising interval. Most of the time these two communs are consecutive, however, there might be several advertising intervals in between as well. It's still unknown why the second commun exists. The structure of the second communication is extremely similar with the first one, except for these aspects:
  1. Different from (4.) above, the Indication value is still 6 bytes, but contains different data: 0x00001D000000.
  2. Different from (5.) above, mostly there're only two Notifications (Sometimes 0, but I think it should be sniffer problem)
  3. Different from (6.) above, there's only one Write Command after the Notifications, and the value is always 0x020000000000000000 (9 bytes).


#### Note: 
  All the data is in little endian mode


## Attributes and Suspicions:

- 0x0015 (Notify): It seems that the attribute 0x0015 contains the patient info, such as heart rate (According to the specification file, the patient info should be encrypted before sent from pacemaker). Because during the communication this attribute keeps notifying ('Notification' is one kind of operation in BLE. The info is sent from slave to master in one direction). 

- 0x0012 (Write): It's assumed that something is written into the attribute 0x0012 to trigger the notification processes, because such Write operations only occur in the communications between Medtronic App and pacemaker. However, the crash of communication between general-used App and pacemaker could due to that the descriptor 0x0016 isn't set as 0x0001 (Notification not enabled) as well. 

- 0x0018 (Indicate): ('Indication' is one kind of operation in BLE. Similar with Notification, its from slave to master. However, a Confirmation is required from master to slave when the master receives the Indication)  For attribute 0x0018, it sends an Indication before the Notifications start to be transmitted. One Indication from this attribute also occurs in the end of the communication, exactly before the final 'LL_TERMINATE_IND'. This Indication might be used to: tell the master to be ready/to stop for receiving Notifications.

- 0x001B (Write Without Response): Besides, some data keeps being written into the attribute 0x001B regularly throughtout the whole Notification sending process. It's unknown why they exist.







