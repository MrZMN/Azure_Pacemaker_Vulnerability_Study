# Azure-Pacemaker-Attack

Sniffering tool: Adafruit Bluefruit LE Friend (unstable, not always be able to capture/ capture all packets :-()

Analysis tool: Wireshark

**All the .pcapng files could only be viewed using Wireshark**

## Files Description:

- The file **'Azure3217 Attribute Table'** contains the attribute table of the pacemaker.

- The capturing file **'Azure pacemaker Packets_generalApp'** contains the packets when using a general-used iOS App 'nRF Connect' to connect with the pacemaker. It shows that although a general master could connect with the pacemaker, it is not permitted to retrieve the patient info from the pacemaker. The connection will crash automatically after the 'discovery process', during which the master gets the GATT info (attribute table) from the slave device.

  It's quite interesting that:
1. There is one extra characteristic declearation and one extra descriptor found whose attribute handles are 0x001D and 0x001F respectively (they were not found in the communications between pacemaker and Medtronic App). 
2. Another difference is that the general-used App didn't write data into the attributes 0x0016 and 0x0019 (two CCC descriptors) to trigger the Notification and Indication respectively, although it writes data into descriptor 0x000F to trigger Indication (This is GATT service so it might be unimportant). And absolutely, nothing is written into the characteristic value attribute 0x0012. As for communication between the Medtronic App and pacemaker, data has been written into both descriptors (0x0016, 0x0019) so that the Notification and Indication of attributes 0x0015 and 0x0018 could work. 

- The capturing files (starting with **'Azure pacemaker Packets'**) contain the packets when using the Medtronic 'MyCareLink Heart' App to connect with the pacemaker. The connection could be triggered using the 'Send Transmission' function of the App, and each file contains the aggregate sniffered packets throughout one 'Send Transmission' process.  All the files show that the connection between the Medtronic App and pacemaker is complete, for example, it starts from master transmitting 'CONNECT_REQ' and ends with master transmitting 'LL_TERMINATE_IND'. By analysing the packets, the attribute table of the pacemaker could be generated (See file **'Azure3217 attribute table'**). One interesting thing is that for the communications between pacemaker and Medtronic App, I could capture two communications in two different advertising intervals (advertising interval is 3 min for pacemaker), and they have the similar structures. The reason why the second communication exists is still unknown.

#### Note: 
  Although lots of attempts, because of the limitation of the sniffering tool, not all the communication info has been captured completely in each file. Ex, for the recording file **'Azure pacemaker Packets1'**, the second communication between pacemaker and Medtronic App is not complete.


## Whole Communication Process (between Medtronic App and pacemaker):

### The first communication:
  1. After the connection is established, the master uses 'Read by group type REQ/RSP', 'Read by type REQ/RSP', 'Find Information REQ/RSP' to learn the info of services, characteristics and descriptors of the slave respectively. 
  2. At the same time, the master writes data into descriptor attributes 0x000F, 0x0016, 0x0019 to trigger the Indication/Notification functions of the slave's characteristics. 
  3. Next, the master writes 30 bytes data into the attribute 0x0012. The 30 bytes are different each time, however, not completely random. For instance, *0x19380200000008000006de526175e4ef9dffcc65982046a80fc573e1a253*, *0x1938010000000700000636903df073fb7a886dfcfd17439bf34508cf7*, *0x1938010000000d0000067766194dfa1ad18cd8643859c0729c0b12371435*. It's still unknown what these data represents.
  4. The slave sends a 6-byte Indication to the master, from attribute 0x0018. These 6 bytes are constant: 0x0000ace10100. There'll be a Confirmation packet sent back to the slave from the master.
  5. The slave keeps sending Notifications to the master from attribute 0x0015 (Over 5000 Notifications totally). Most of the Notifications contain 20 bytes value, however, it's found that a few contain 18 bytes/8 bytes/2 bytes as well (occur at last). The number of Notifications varies in each test. (I think it might be the sniffer problem, but haven't proved)
  6. During the period of slave sending Notifications, the master keeps sending the Write Commands on attribute 0x001B regularly (Write again after about 10-20 Notifications). The value of each Write contains 9 bytes. The interesting thing is that, only the Least Significant byte (LSB) is not 0x00. The LSB values of the first Write Commands are always '0x14', '0x28', '0x3C', etc, and the value of the last Write Command is always '0xF9'. However, for the values in the middle Write Commands, they are not always the same in each test. (I think it might be the sniffer problem, but haven't proved)
  7. After all Notifications are sent, the salve will send a 2-byte Indication from attribute 0x0018. The content is constant: 0x0200. There's no Confirmation packet from the master.
  8. After receiving the Indication, the master sends back an 'LL_TERMINATE_IND' packet. The whole connection is over.
  
### The second communication:
  The second communication between the Medtronic App and the pacemaker happens in a different slave's advertising interval. Most of the time these two communs are consecutive, however, there might be several advertising intervals in the middle as well. It's still unknown why the second commun exists. The structure of the second communication is extremely similar with the first one, except for these aspects:
  1. Different from (4.) above, the Indication value is still 6 bytes, but contains different data: 0x00001D000000.
  2. Different from (5.) above, mostly there're only two Notifications (Sometimes 0, but I think it should be sniffer problem)
  3. Different from (6.) above, there's only one Write Command after the Notifications, and the value is always 0x020000000000000000 (9 bytes).


#### Note: 
  All the data is in little endian mode


## Attributes and Suspicions:

- 0x0015 (Notify): It seems that the attribute 0x0015 contains the patient info, such as heart rate (According to the specification file, the patient info should be encrypted before sent from pacemaker). Because during the communication this attribute keeps notifying ('Notification' is one kind of operation in BLE. The info is sent from slave to master in one direction). 

- 0x0012 (Write): It's assumed that something is written into the attribute 0x0012 to trigger the notification processes, because such Write operations only occur in the communications between Medtronic App and pacemaker. However, the crash of communication between general-used App and pacemaker could due to that the descriptor 0x0016 isn't set as 0x0001 as well. 

- 0x0018 (Indicate): For attribute 0x0018, it sends an Indication ('Indication' is one kind of operation in BLE. Similar with Notification, its from slave to master. However, a Confirmation is required from master to slave when the master receives the Indication) before the Notifications start to be transmitted. One Indication from this attribute also occurs in the end of the communication, exactly before the final 'LL_TERMINATE_IND'. This Indication might be used to: tell the master to be ready/to stop for receiving Notifications.

- 0x001B (Write Without Response): Besides, some data keeps being written into the attribute 0x001B regularly throughtout the whole Notification sending process. It's unknown why they exist.







